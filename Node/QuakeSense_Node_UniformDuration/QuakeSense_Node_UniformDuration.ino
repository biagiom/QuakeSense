/*
 *  QuakeSense_Node_UniformDuration
 * 
 *  QuakeSense is an IoT project that aims to "sense" and monitor earthquakes through a Lora network.
 * 
 *  The main elements of this project are:
 *  1) At least one Sensor Node (Mote) consisting of:
 *     - a 3-axis accelerometer used to measure strong ground motion activity.
 *     - a LoRa radio module used to transmit an alarm and the main parameters that
 *       characterize the strong motion activity to a single channel LoRa gateway
 *     - A GPS module used to get altitude, longitude and latitude of
 *       the area where the seismic event occurs.
 *     - a development board that is used to control the accelerometer,
 *       the LoRa module and the GPS module.
 *     - a LiPo battery used to power the development board.
 *     - a solar panel used to charge the LiPo battery.
 *
 *     In this implementation, the sensor node has been made with:
 *     > X-NUCLEO-IKS01A2 motion MEMS and environmental sensor expansion board including
 *       * LSM6DSL: MEMS 3D accelerometer and 3D gyroscope
 *       * LSM303AGR: MEMS 3D accelerometer and magnetometer
 *       * LPS22HB: MEMS pressure sensor
 *       * HTS221: capacitive digital relative humidity and temperature sensor
 *     > STM32 Nucleo F401RE as the development board
 *     > Dragino LoRa/GPS Shield including
 *       - RFM95W 137 MHz to 1020 MHz low-power, long-range LoRa RF transceiver
 *       - Quectel L80 GPS module based on MTK MT3339
 *     > Seed Studio Solar Charger shield v2.2 to which are connected
 *       a 2000 mAh LiPo battery and a 1.5 W solar panel
 *
 *     In presence of a seismic event, the STM32 Nucleo board reads acceleration samples from
 *     the LSM6DSL sensor to calculate some of the main parameters that characterize the 
 *     strong-motion activity: bracketed duration and peak ground acceleration 
 *     relative to the three components of the motion (x, y and z).
 *     Each sensor node uses periodically the HTS221 and LPS22HB environmental sensors to get
 *     temperature, relative humidity and pressure and send these values to the gateway.
 *
 *  2) A LoRa gateway that receives environmental data and earthquake alert messages
 *     from the sensor nodes and sends them to a IoT Platform.
 *
 *     In this implementation, the LoRa gateway has been made with:
 *     > B-L475E-IOT01A2 STM32L4 Discovery kit IoT node featuring:
 *       - Wi-Fi module Inventek ISM43362-M3G-L44 (802.11.4 b/g/n compliant)
 *       - SPSGRF-868: Sub-GHz (868 Mhz) low-power RF module
 *       - SPBTLE-RF: Bluetooth V4.1 module
 *       - HTS221: capacitive relative humidity and temperature sensor
 *       - LSM303AGR: MEMS 3D accelerometer and MEMS 3D magnetometer
 *       - LSM6DSL: MEMS 3D accelerometer and MEMS 3D gyroscope
 *       - LSP22HB: 260-1260 hPa absolute digital output barometer
 *     > Dragino LoRa Shield which includes:
 *       - the RFM95W low-power, long-range LoRa RF transceiver based on SX1276
 *
 *  3) A cloud platform that allows the user to visualize the earthquake status,
 *     alarm messages and envirnmental data in real-time.
 *     In the following implementation, AdafruitIO has been choosen as the cloud platform
 *     and data coming from the LoRa gateway is sent to Adafruit IO using the MQTT protocol.
 *
 *  This sketch uses the STM32LowPower library in order to put the STM32 MCU in deep sleep 
 *  low-power mode (STM32 stop mode) to save battery energy.
 *  The node wakes up from low-power mode using interrupt generated by the LSM6DSL accelerometer when
 *  a seismic event occurs or using RTC when the Sensor Node has to send environmental data to the gateway.
 *  To optimize battery life and reduce current consumption the LoRa radio module is put in Stanby Mode
 *  instead the GPS module is put in AlwaysLocate mode.
 *
 *  Copyright (C) Biagio Montaruli <biagio.hkr@gmail.com>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 */

// Include sensor's library
#include <HTS221Sensor.h>
#include <LPS22HBSensor.h>
#include <LSM6DSLSensor.h>
// Include STM32LowPower library
#include <STM32LowPower.h>
// Include Adafruit GPS library for MT3339 GPS module
#include <Adafruit_GPS.h>
// include SPI library and LoRa library
#include <SPI.h>
#include <LoRa.h>

// Change these values according to your implementation
#define ENABLE_ENV_SENSORS 1
#define PRINT_ENV_DATA 1
#define SEND_ENV_DATA 1
#define DEBUG_LORA_PACKET 1
#define PRINT_ACC_DATA  0
#define PRINT_GPS_DATA 1
#define GPS_FIX_TIME 1
#define GPS_MODE_ALWAYSLOCATE
//#define GPS_MODE_STANDBY
#define SERIAL_DEBUG 1
#define PRINT_EARTHQUAKE_VALUES 1

#if (PRINT_ENV_DATA == 1)  || (DEBUG_LORA_PACKET == 1) || \
    (PRINT_ACC_DATA == 1)  || (PRINT_GPS_DATA == 1)    || \
    (SERIAL_DEBUG == 1)    || (PRINT_EARTHQUAKE_VALUES == 1)
#define ENABLE_SERIAL 1
#else
#define ENABLE_SERIAL 0
#endif

#define PGHAX_THRESHOLD 50
#define PGHAY_THRESHOLD 50
#define PGVA_THRESHOLD 1120

volatile bool earthquakeDetected = false;
volatile bool motionDetected = false;

#define DEV_I2C Wire

// Use Serial2 port (USART2 on PA1, PA0) to print data in the Serial Monitor
#define SerialPort Serial

// For GPS data use Serial6 port (USART6 on PA_12 (RX) and PA_11 (TX))
HardwareSerial GPSSerial(PA_12, PA_11);

Adafruit_GPS GPS(&GPSSerial);

#define GPS_READ_TIME 2000
bool isGPSDataValid = false;

#if defined(GPS_MODE_ALWAYSLOCATE)
#undef GPS_MODE_STANDBY
#elif defined(GPS_MODE_STANDBY)
#undef GPS_MODE_ALWAYSLOCATE
#endif

const int csPin = 10;         // LoRa radio chip select
const int resetPin = 9;       // LoRa radio reset
const int irqPin = 2;         // change for your board; must be a hardware interrupt pin

byte msgCount = 0;            // count of sent messages
byte nodeAddress = 0xAA;      // address of this device (LoRa Node)
byte gatewayAddress = 0xBB;   // address of the receiver (LoRa gateway)

bool loraInit = false;

// Objects for environmental sensors
#if ENABLE_ENV_SENSORS == 1
HTS221Sensor *HTS221_HumTemp;
LPS22HBSensor *LPS22HB_Press;

bool getEnvData = true;

// time interval to update the environmental data:
// temperature, humidity and pressure: 15 minutes
#define ENVDATA_UPDATE_TIME_MIN 15

#define ENVDATA_UPDATE_TIME_MILLIS (ENVDATA_UPDATE_TIME_MIN * 60000)
#endif

LSM6DSLSensor *LSM6DSL_AccGyro;

// Output data rate of LSM6DSL Accelerometer
// Available values: 13 Hz, 26 Hz, 52 Hz, 104 Hz, 208 Hz, 416 Hz,
//                   833 Hz, 1660 Hz, 3330 Hz, 6660 Hz
#define LSM6DSL_ACC_ODR LSM6DSL_ACC_GYRO_ODR_XL_104Hz
// Full scale range of LSM&DSL Accelerometer
// Available values: 2g, 4g, 8g, 16g
#define LSM6DSL_ACC_FS  LSM6DSL_ACC_GYRO_FS_XL_2g

const uint32_t timeWindow = 50000;
uint32_t uniformDuration = 0;
int32_t pghaxSum = 0;
int32_t pghaySum = 0;
int32_t pgvaSum = 0;
// Maximum number of samples read by the accelerometer
// each sample is characterized by 3 values
#define MAX_SAMPLES 1024

typedef enum {
  LSM6DSL_X_AXIS = 0,
  LSM6DSL_Y_AXIS = 1,
  LSM6DSL_Z_AXIS = 2,
  LSM6DSL_NUM_AXIS = 3
} LSM6DSL_ACC_AXIS;

volatile uint16_t counter = 0;

const int wakeupPin = PA0;

void setup() {

#if ENABLE_SERIAL == 1
  // Initialize Serial communication at 115200 bps.
  SerialPort.begin(115200);
  // wait for the Serial port to open
  while (!SerialPort);
#endif

  // Initialize I2C bus.
  DEV_I2C.begin();

  LowPower.begin();

  // Enable interrupts to wake up the STM32 MCU when the LSM6DSL accelerometer
  // starts to send new samples.
  // NOTE: Remember to connect the D5 pin to the A0 pin in order to redirect the
  // interrupt generated by the LSM6DSL to the wake up pin (AO)
  LowPower.attachInterruptWakeup(wakeupPin, motionEventCB, RISING);

  // Enable and initialize environmental sensors.
#if ENABLE_ENV_SENSORS == 1
  // Create a new object that represents the HTS221 humidity and temperature sensor and enable it
  HTS221_HumTemp = new HTS221Sensor(&DEV_I2C);
  HTS221_HumTemp->Enable();
  // Create a new object that represents the LPS22HB pressure sensor and enable it
  LPS22HB_Press = new LPS22HBSensor(&DEV_I2C);
  LPS22HB_Press->Enable();
#endif

  // Create a new object that represents the LSM6DSL accelemometer
  // gyroscope and enable them
  LSM6DSL_AccGyro = new LSM6DSLSensor(&DEV_I2C);
  LSM6DSL_AccGyro->Enable_X();

  // Set LSM6DSL Accelerometer full scale
  LSM6DSL_AccGyro->Set_X_FS(LSM6DSL_ACC_FS);
  // Set LSM6DSL Accelerometer output data rate
  LSM6DSL_AccGyro->Set_X_ODR(LSM6DSL_ACC_ODR);

  // Enable wake up detection
  LSM6DSL_AccGyro->Enable_Wake_Up_Detection();
  // Enable single tap and double tap detection
  LSM6DSL_AccGyro->Enable_Single_Tap_Detection(LSM6DSL_INT2_PIN);
  LSM6DSL_AccGyro->Enable_Double_Tap_Detection(LSM6DSL_INT2_PIN);
  // enable tilt detection
  LSM6DSL_AccGyro->Enable_Tilt_Detection(LSM6DSL_INT2_PIN);

  // set CS, reset, IRQ pins for LoRa module
  LoRa.setPins(csPin, resetPin, irqPin);

  // Set LoRa frequency band to 868 MHz
  if (!LoRa.begin(868E6)) {
  #if SERIAL_DEBUG == 1
    SerialPort.println("LoRa init failed. Check your connections.");
  #endif
  }
  #if SERIAL_DEBUG == 1
  SerialPort.println("LoRa module successfully initialized.");
  #endif
  loraInit = true;
  // Set LoRa Mode 3
  // BW = 125 kHz; CR = 4/5; SF = 10
  LoRa.setSpreadingFactor(10);
  LoRa.setSignalBandwidth(125E3);
  LoRa.setCodingRate4(5);
  // set TX power to 13 dBm
  LoRa.setTxPower(13);

  // 9600 NMEA is the default baud rate for MTK GPS's
  GPS.begin(9600);

  // Turn on RMC and GGA (fix data) including altitude
  GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA);
  // Set the update rate for the GPS Module to 1 Hz
  GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ);
  // Request updates on antenna status
  GPS.sendCommand(PGCMD_ANTENNA);

  delay(20000);

  updateGPSData();

  delay(2000);

#if defined(GPS_MODE_STANDBY)
  // switch to standby mode to save energy:
  if (GPS.setStandbyMode()) {
  #if SERIAL_DEBUG == 1
    SerialPort.println("GPS module in Standby mode");
  #endif
  }
  else {
  #if SERIAL_DEBUG == 1
    SerialPort.println("Failed to set GPS module in Standby mode");
  #endif
  }
#elif defined(GPS_MODE_ALWAYSLOCATE)
  // switch to AlwaysLocate mode to save energy
  if (GPS.setAlwaysLocateMode()) {
  #if SERIAL_DEBUG == 1
    SerialPort.println("GPS module in AlwaysLocate mode");
  #endif
  }
  else {
  #if SERIAL_DEBUG == 1
    SerialPort.println("Failed to set GPS module in AlwaysLocate mode");
  #endif
  }
#endif

  LoRa.sleep();
}

void loop() {

#if ENABLE_ENV_SENSORS == 1
  if (getEnvData == true) {
    // Read humidity and temperature from HTS221 sensor.
    float hts221_humidity, hts221_temperature;
    HTS221_HumTemp->GetHumidity(&hts221_humidity);
    HTS221_HumTemp->GetTemperature(&hts221_temperature);

    // Read pressure and temperature from LPS22HB sensor.
    float lps22hb_pressure;
    LPS22HB_Press->GetPressure(&lps22hb_pressure);

    // Output environmenral data to the Serial monitor and if PRINT_ENV_DATA is equals to 1
  #if PRINT_ENV_DATA == 1
    SerialPort.print("Humidity[%]: ");
    SerialPort.println(hts221_humidity, 2);
    SerialPort.print("Temperature[°C]: ");
    SerialPort.println(hts221_temperature, 2);
    SerialPort.print("Presure[mbar]: ");
    SerialPort.println(lps22hb_pressure, 2);
  #endif
    // send humidity, temperature and pressure values to the LoRa gateway if SEND_ENV_DATA is 1
  #if SEND_ENV_DATA == 1
    // Build LoRa message
    String msg = "#TEMP=" + String(hts221_temperature, 2) +
                 "#HUM=" + String(hts221_humidity, 2) +
                 "#PRESS=" + String(lps22hb_pressure, 2);
  #if DEBUG_LORA_PACKET == 1
    Serial.println("Lora packet sent:");
    Serial.println(msg);
  #endif    // DEBUG_LORA_PACKET
  sendLoraPacket(msg);
  #endif    // SEND_ENV_DATA
  }
  #endif   // ENABLE_ENV_SENSORS

#if SERIAL_DEBUG == 1
  SerialPort.println("Starting Deep Sleep low-power mode (STM32 Stop mode)...");
  delay(100);
#endif

  LowPower.deepSleep(ENVDATA_UPDATE_TIME_MILLIS);

  if (motionDetected == true) {
    motionDetected = false;

    if (earthquakeDetected == true) {
      earthquakeDetected = false;
      getEnvData = false;

      uint32_t remainingTime = timeWindow - uniformDuration;

      while (true) {
      #if SERIAL_DEBUG == 1
        SerialPort.print("Starting deep sleep mode for ");
        SerialPort.print(remainingTime);
        SerialPort.println(" millis...");
        delay(50);
      #endif
        LowPower.deepSleep(remainingTime);

        if (motionDetected == true) {
          if (earthquakeDetected == true) {
            if ((remainingTime - uniformDuration) < 0) {
              break;
            }
            else {
              remainingTime = remainingTime - uniformDuration;
            }
            earthquakeDetected = false;
          }
          motionDetected = false;
        }
        else {
          break;
        }
      }
    #if SERIAL_DEBUG == 1
      SerialPort.println("Sending earthquake alarm...");
    #endif
      sendEarthquakeData();
    }
  }
  else {
  #if SERIAL_DEBUG == 1
    SerialPort.println("Waking up from deep sleep mode to send environmental data...");
  #endif
    getEnvData = true;
  }
}

void motionEventCB() {
  LSM6DSL_Event_Status_t status;
  LSM6DSL_AccGyro->Get_Event_Status(&status);

  motionDetected = true;

  if (status.WakeUpStatus && !status.TapStatus && !status.DoubleTapStatus && !status.TiltStatus) {
  #if SERIAL_DEBUG == 1
    SerialPort.println("WakeUP event -> Motion Detected!");
    SerialPort.println("Waking up from Deep Sleep mode...");
  #endif
    earthquakeDetection();
  }
}

void earthquakeDetection() {
  uint32_t quake_start_time = 0;
  uint32_t quake_end_time = 0;
  uint32_t duration = 0;

  // Read accelerometer samples:
  int32_t lsm6dsl_acc[MAX_SAMPLES][LSM6DSL_NUM_AXIS];

  uint16_t n;

  for (n = 0; n < MAX_SAMPLES; n++) {
    LSM6DSL_AccGyro->Get_X_Axes(lsm6dsl_acc[n]);

    if ( (abs(lsm6dsl_acc[n][LSM6DSL_X_AXIS]) >= PGHAX_THRESHOLD) || \
         (abs(lsm6dsl_acc[n][LSM6DSL_Y_AXIS]) >= PGHAY_THRESHOLD) || \
         (abs(lsm6dsl_acc[n][LSM6DSL_Z_AXIS]) >= PGVA_THRESHOLD) ) {

      if (n == 0) {
        quake_start_time = millis();
      }
    }
    else {
      break;
    }
  }
  quake_end_time = millis();

  if (n > 0) {
    duration = quake_end_time - quake_start_time;
    uniformDuration += duration;
    counter++;

    earthquakeDetected = true;

  #if PRINT_ACC_DATA == 1
    for (uint16_t i = 0; i < n; i++) {
      SerialPort.println("Accelerometer[mg]:");
      SerialPort.print("x-axis: ");
      SerialPort.println(lsm6dsl_acc[i][LSM6DSL_X_AXIS]);
      SerialPort.print("y-axis: ");
      SerialPort.println(lsm6dsl_acc[i][LSM6DSL_Y_AXIS]);
      SerialPort.print("z-axis: ");
      SerialPort.println(lsm6dsl_acc[i][LSM6DSL_Z_AXIS]);
    }
  #endif

    // calculate peak ground horizontal acceleration (PGHA)
    // for x-axis and y-axis
    uint32_t pghax = abs(lsm6dsl_acc[0][LSM6DSL_X_AXIS]);
    uint32_t pghay = abs(lsm6dsl_acc[0][LSM6DSL_Y_AXIS]);

    // peak ground vertical acceleration (z-axis): PGVA
    uint32_t pgva = abs(lsm6dsl_acc[0][LSM6DSL_Z_AXIS]);

    for (uint16_t i = 1; i < n; i++) {
      if (pghax < abs(lsm6dsl_acc[i][LSM6DSL_X_AXIS])) {
        pghax = abs(lsm6dsl_acc[i][LSM6DSL_X_AXIS]);
      }
      if (pghay < abs(lsm6dsl_acc[i][LSM6DSL_Y_AXIS])) {
        pghay = abs(lsm6dsl_acc[i][LSM6DSL_Y_AXIS]);
      }
      if (pgva < abs(lsm6dsl_acc[i][LSM6DSL_Z_AXIS])) {
        pgva = abs(lsm6dsl_acc[i][LSM6DSL_Z_AXIS]);
      }
    }

    pghaxSum += pghax;
    pghaySum += pghay;
    pgvaSum += pgva;

  #if PRINT_EARTHQUAKE_VALUES == 1
    SerialPort.print("Earthquake event duration: ");
    SerialPort.print(duration);
    SerialPort.println(" msecs");

    SerialPort.print("PGHAX (x-axis): ");
    SerialPort.println(pghax);
    SerialPort.print("PGHAY (y-axis): ");
    SerialPort.println(pghay);
    SerialPort.print("PGVA (z-axis): ");
    SerialPort.println(pgva);

    SerialPort.print("Got ");
    SerialPort.print(n);
    SerialPort.println(" samples.");
  #endif
  }
}

void sendEarthquakeData() {

#if defined(GPS_MODE_STANDBY) || defined(GPS_MODE_ALWAYSLOCATE)

#if defined(GPS_MODE_STANDBY)
  // switch from standby to Full On mode
  if (GPS.wakeupStandby()) {
#elif defined(GPS_MODE_ALWAYSLOCATE)
  // switch from AlwaysLocate mode to Full On mode
  if (GPS.wakeupAlwaysLocate()) {
#endif
  #if SERIAL_DEBUG == 1
    SerialPort.println("GPS module in Full On mode");
  #endif
  }
  else {
  #if SERIAL_DEBUG == 1
    SerialPort.println("Failed to set GPS module in Full On mode");
  #endif
  }
#endif

  delay(3000);

  updateGPSData();

#if SERIAL_DEBUG == 1
  SerialPort.print("Earthquake event counter: ");
  SerialPort.println(counter);
#endif

  int32_t pghaxMean = pghaxSum / counter;
  int32_t pghayMean = pghaySum / counter;
  int32_t pgvaMean = pgvaSum / counter;

#if PRINT_EARTHQUAKE_VALUES == 1
  SerialPort.print("PGHAX Mean: ");
  SerialPort.println(pghaxMean);
  SerialPort.print("PGHAY Mean: ");
  SerialPort.println(pghayMean);
  SerialPort.print("PGVA Mean: ");
  SerialPort.println(pgvaMean);
  SerialPort.print("Uniform duration: ");
  SerialPort.println(uniformDuration);
#endif

  if (loraInit) {
    String msg = "#ALERT!";
    msg += "#PGHAX=";
    msg += String(pghaxMean);
    msg += "#PGHAY=";
    msg += String(pghayMean);
    msg += "#PGVA=";
    msg += String(pgvaMean);
    msg += "#DUR=";
    msg += String(uniformDuration);

    if (isGPSDataValid) {
      msg += "#LAT=";
      msg += String(GPS.getLatitude(), 2);
      msg += String(GPS.getLatCardinalDir());
      msg += "#LON=";
      msg += String(GPS.getLongitude(), 2);
      msg += String(GPS.getLonCardinalDir());
      msg += "#ALT=";
      msg += String(GPS.getAltitude(), 2);
      msg += "#DATE=";
      if (GPS.getDay() < 10)
        msg += "0";
      msg += (String(GPS.getDay()) + "/");
      if (GPS.getMonth() < 10)
        msg += "0";
      msg += (String(GPS.getMonth()) + "/20");
      if (GPS.getYear() < 10)
        msg += "0";
      msg += String(GPS.getYear());
      msg += "#TIME=";
    #if GPS_FIX_TIME == 1
      if ((GPS.getHour() + 1) < 10)
        msg += "0";
      msg += (String(GPS.getHour() + 1) + ":");
    #else
      if (GPS.getHour() < 10)
        msg += "0";
      msg += (String(GPS.getHour()) + ":");
    #endif
      if (GPS.getMinutes() < 10)
        msg += "0";
      msg += String(GPS.getMinutes()) +  ":";
      if (GPS.getSeconds() < 10)
        msg += "0";
      msg += String(GPS.getSeconds());
    }

  #if DEBUG_LORA_PACKET == 1
    Serial.println("Lora packet sent:");
    Serial.println(msg);
  #endif

    sendLoraPacket(msg);
  }

#if defined(GPS_MODE_STANDBY)
  // switch to standby mode to save energy:
  delay(1000);
  if (GPS.setStandbyMode()) {
  #if SERIAL_DEBUG == 1
    SerialPort.println("GPS module in Standby mode");
  #endif
  }
  else {
  #if SERIAL_DEBUG == 1
    SerialPort.println("Failed to set GPS module in Standby mode");
  #endif
  }
#elif defined(GPS_MODE_ALWAYSLOCATE)
  // switch to AlwaysLocate mode to save energy
  if (GPS.setAlwaysLocateMode()) {
  #if SERIAL_DEBUG == 1
    SerialPort.println("GPS module in AlwaysLocate mode");
  #endif
  }
  else {
  #if SERIAL_DEBUG == 1
    SerialPort.println("Failed to set GPS module in AlwaysLocate mode");
  #endif
  }
#endif

  LoRa.sleep();

  pghaxMean = pghayMean = pgvaMean = uniformDuration = counter = 0;
}

// Function that builds a LoRa packet and sends it.
// The format of the LoRa packet is:
// | Destination |   Sender   |  Message ID  | Payload Length |  Payload data |
//    1 byte         1 byte       1 byte          1 byte           N byte
void sendLoraPacket(String data) {
  LoRa.beginPacket();           // start packet
  LoRa.write(gatewayAddress);   // add destination address
  LoRa.write(nodeAddress);      // add sender address
  LoRa.write(msgCount);         // add message ID
  LoRa.write(data.length());    // add payload length
  LoRa.print(data);             // add payload
  LoRa.endPacket();             // finish packet and send it
  msgCount++;                   // increment message ID
}

// Function that reads data from the GPS module, parse it to get:
// latitude, longitude, altitude, time, date and other GPS values.
void updateGPSData() {
  uint32_t gpsTimer = millis();

  bool NMEAparsed = false;
  while (millis() - gpsTimer < GPS_READ_TIME) {
    // read data from the GPS
    char c = GPS.read();

  #if (PRINT_GPS_DATA == 1) && (SERIAL_DEBUG == 1)
    // print GPS data in the Serial monitor
    if (c) SerialPort.print(c);
  #endif

    if (GPS.newNMEAreceived()) {
      // if a sentence is received, we can check the checksum and parse it...
      // we can fail to parse a sentence in which case we should just wait for another
      // this also sets the newNMEAreceived() flag to false
    #if (PRINT_GPS_DATA == 1) && (SERIAL_DEBUG == 1)
      SerialPort.println(GPS.lastNMEA());
    #endif
      if (GPS.parse(GPS.lastNMEA())) {
        NMEAparsed = true;
        break;
      }
    }
  }

  if (NMEAparsed == true) {

  #if PRINT_GPS_DATA == 1
    SerialPort.print("\nTime: ");
  #if GPS_FIX_TIME == 1
    SerialPort.print((GPS.getHour() + 1), DEC);
  #else
    SerialPort.print(GPS.getHour(), DEC);
  #endif
    SerialPort.print(':');
    if (GPS.getMinutes() < 10)
      Serial.print("0");
    SerialPort.print(GPS.getMinutes(), DEC);
    SerialPort.print(':');
    if (GPS.getSeconds() < 10)
      Serial.print("0");
    SerialPort.print(GPS.getSeconds(), DEC);
    SerialPort.print('.');
    if (GPS.getMilliseconds() < 10)
      Serial.print("0");
    SerialPort.println(GPS.getMilliseconds());
    SerialPort.print("Date: ");
    if (GPS.getDay() < 10)
      Serial.print("0");
    SerialPort.print(GPS.getDay(), DEC); SerialPort.print('/');
    if (GPS.getMonth() < 10)
      Serial.print("0");
    SerialPort.print(GPS.getMonth(), DEC); SerialPort.print("/20");
    if (GPS.getYear() < 10)
      Serial.print("0");
    SerialPort.println(GPS.getYear(), DEC);
    SerialPort.print("Fix: "); SerialPort.print(GPS.isFixed());
    SerialPort.print(" quality: "); SerialPort.println(GPS.getQuality());
  #endif

    if (GPS.isFixed() || GPS.getQuality()) {

    #if PRINT_GPS_DATA == 1
      SerialPort.print("Location: ");
      SerialPort.print(GPS.getLatitude(), 4); SerialPort.print(GPS.getLatCardinalDir());
      SerialPort.print(", ");
      SerialPort.print(GPS.getLongitude(), 4); SerialPort.println(GPS.getLonCardinalDir());
      SerialPort.print("Speed (knots): "); SerialPort.println(GPS.getSpeed());
      SerialPort.print("Angle: "); SerialPort.println(GPS.getAngle());
      SerialPort.print("Altitude: "); SerialPort.println(GPS.getAltitude());
      SerialPort.print("Satellites: "); SerialPort.println(GPS.getSatellites());
    #endif

      isGPSDataValid = true;
    }
    else {
      isGPSDataValid = false;
    }
  }
}
